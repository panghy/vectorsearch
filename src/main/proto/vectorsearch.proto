syntax = "proto3";

package vectorsearch;

import "google/protobuf/timestamp.proto";

// Java codegen options: place messages in a stable package and split into files.
option java_package = "io.github.panghy.vectorsearch.proto";
option java_multiple_files = true;
option java_outer_classname = "VectorSearchProto";

// -----------------------------------------------------------------------------
// Overview
// -----------------------------------------------------------------------------
// These protos describe the on-disk (FoundationDB) representation of the vector
// index. All data lives under DirectoryLayer-managed subspaces (see roadmap).
//
// Conventions:
// - All IDs (segment_id, vec_id) are local to the segment, unless stated.
// - Keys are built with Tuple packing to ensure natural ordering / grouping.
// - Embeddings are stored as packed little-endian float32 in bytes fields.
// - Timestamps are milliseconds since epoch unless specified.
// - Messages are designed to be forward-compatible; prefer adding fields over
//   modifying existing ones. Avoid changing semantics of existing fields.

// -----------------------------------------------------------------------------
// Global index metadata
// -----------------------------------------------------------------------------
// Stored once per index (key: (index, "meta") inside the index directory).
// This is written at index creation and rarely changes.
message IndexMeta {
  // Human-readable index name; also used for DirectoryLayer naming.
  string name = 1;

  // Fixed vector dimensionality (D). Must be positive and immutable across the
  // lifetime of the index. All inserted vectors MUST have this dimension.
  int32 dimension = 2;

  // Distance metric used for scoring / search pruning.
  // - METRIC_L2: Euclidean distance in R^D
  // - METRIC_COSINE: Cosine similarity (dot product on normalized vectors)
  enum Metric { METRIC_L2 = 0; METRIC_COSINE = 1; }
  Metric metric = 3;

  // Maximum number of vectors per segment before it rotates to PENDING.
  // Typical values: 50k–200k depending on memory and quality targets.
  int32 max_segment_size = 4;

  // Product Quantization (PQ) configuration:
  // - m: number of subspaces (must divide dimension)
  // - k: number of centroids per subspace (commonly 256 → 1 byte per subspace)
  int32 pq_m = 5;
  int32 pq_k = 6;

  // Graph configuration:
  // - graph_degree: target out-degree R for DiskANN-style neighbor graph
  // - oversample: multiplier of K for candidate collection before exact rerank
  int32 graph_degree = 7;
  int32 oversample = 8;
  // Graph build breadth (L_build): how many nearest candidates to consider
  // when constructing neighbors (before pruning). Typical values: graph_degree*4.
  int32 graph_build_breadth = 9;
  // Vamana-style pruning alpha parameter (>1.0). Lower removes more edges.
  // Set to 0 or 1 to disable pruning (keep top-L_build by distance).
  double graph_alpha = 10;

}

// -----------------------------------------------------------------------------
// Per-segment metadata
// -----------------------------------------------------------------------------
// Stored at: (segments, <segIdStr>, "meta") or equivalent flattened key.
// Maintains the lifecycle state and counters for a single segment.
message SegmentMeta {
  // Segment identifier (0-based, monotonically increasing number).
  int32 segment_id = 1;

  // Lifecycle state:
  // ACTIVE: accepting writes and visible to queries via brute-force.
  // PENDING: rotation happened; no more writes, visible via brute-force until sealed.
  // SEALED: background-built with PQ/graph; visible to queries via index.
  // COMPACTING: source of an in-progress compaction; still searched like SEALED.
  // WRITING: destination segment for compaction writes; not visible to queries.
  enum State { ACTIVE = 0; PENDING = 1; SEALED = 2; COMPACTING = 3; WRITING = 4; }
  State state = 2;

  // Number of non-deleted vectors currently in this segment.
  // For ACTIVE segments, this is the next vec_id to assign.
  int32 count = 3;

  // Creation time (ms since epoch). Useful for TTL, compaction heuristics, and
  // operational visibility. Not used in correctness.
  int64 created_at_ms = 4;

  // Number of vectors marked deleted in this segment. Helps maintenance tasks
  // (vacuum/compaction) decide when to reclaim space.
  int64 deleted_count = 5;

  // Last time a vacuum job completed for this segment (ms since epoch). Optional.
  int64 last_vacuum_at_ms = 6;
}

// -----------------------------------------------------------------------------
// Raw vector record stored under segment/vectors
// -----------------------------------------------------------------------------
// Keyed under: (segments, <segIdStr>, "vectors", <vecId>)
// Embeddings are stored in raw form for exact reranking and for ACTIVE search.
message VectorRecord {
  // Segment-local identifiers. Together (seg_id, vec_id) uniquely identify a
  // record. Global IDs, if needed externally, can be encoded via Tuple.
  int32 seg_id = 1;
  int32 vec_id = 2;

  // Packed little-endian float32 array of length = IndexMeta.dimension.
  // For cosine, callers should either pre-normalize vectors or the query path
  // should normalize on read before computing dot products.
  bytes embedding = 3;

  // Tombstone flag. True indicates the record is logically deleted. Adjacency
  // lists are not immediately updated; queries must filter deleted results.
  bool deleted = 4;

  // Optional application payload (opaque bytes). Size should be modest — for
  // large documents/metadata, store elsewhere keyed by (seg_id, vec_id).
  bytes payload = 5;
}

// -----------------------------------------------------------------------------
// Product Quantization (codebook)
// -----------------------------------------------------------------------------
// Stored once per SEALED segment:
//   (segments, <segIdStr>, "pq", "codebook")
// Each entry in `centroids` is a packed float32 array for one subspace that
// concatenates its K centroids (size = K * (D/M)).
message PQCodebook {
  // Number of subspaces (M). Must divide IndexMeta.dimension.
  int32 m = 1;
  // Centroids per subspace (K). Typically 256.
  int32 k = 2;
  // Length = m. Each element packs K centroids for one subspace.
  repeated bytes centroids = 3;
}

// -----------------------------------------------------------------------------
// Graph adjacency (DiskANN-style)
// -----------------------------------------------------------------------------
// Stored per vector for SEALED segments:
//   (segments, <segIdStr>, "graph", <vecId>)
// Contains IDs of neighbor vectors (segment-local). Degree is ~IndexMeta.graph_degree.
message Adjacency {
  // Neighbor IDs (segment-local vec_id). Order is implementation-defined; often
  // by increasing approximate proximity during construction. Consumers may
  // reorder or trim during search.
  repeated int32 neighbor_ids = 1;
}

// -----------------------------------------------------------------------------
// Task payload for background segment build
// -----------------------------------------------------------------------------
// Enqueued when a segment transitions from ACTIVE to PENDING.
message BuildTask {
  // Segment id that has been sealed (PENDING) and needs graph/PQ build.
  int32 seg_id = 1;
}

// -----------------------------------------------------------------------------
// Maintenance tasks (vacuum, compaction)
// -----------------------------------------------------------------------------
// Enqueued out-of-band to reclaim space from tombstoned vectors and (later) merge
// small segments. Vacuum is safe for v1; compaction is a no-op skeleton for now.
message MaintenanceTask {
  oneof task {
    Vacuum vacuum = 1;
    Compact compact = 2;
    FindCompactionCandidates find_candidates = 3;
  }

  message Vacuum {
    int32 seg_id = 1;
    // Optional guard: only vacuum if deleted_count / (deleted_count + count) >= threshold.
    // Use 0 to always vacuum.
    double min_deleted_ratio = 2;
  }

  message Compact {
    repeated int32 seg_ids = 1;
  }

  // Schedules a follow-up task to discover a compactible set of segments given an anchor.
  // The worker will scan sealed segments and choose a small set to merge, then call
  // requestCompaction() with the chosen seg_ids.
  message FindCompactionCandidates {
    int32 anchor_seg_id = 1;
  }
}
