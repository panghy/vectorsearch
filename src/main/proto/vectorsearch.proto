syntax = "proto3";

package vectorsearch;

import "google/protobuf/timestamp.proto";

// Java codegen options: place messages in a stable package and split into files.
option java_package = "io.github.panghy.vectorsearch.proto";
option java_multiple_files = true;
option java_outer_classname = "VectorSearchProto";

// -----------------------------------------------------------------------------
// Overview
// -----------------------------------------------------------------------------
// These protos describe the on-disk (FoundationDB) representation of the vector
// index. All data lives under DirectoryLayer-managed subspaces (see roadmap).
//
// Conventions:
// - All IDs (segment_id, vec_id) are local to the segment, unless stated.
// - Keys are built with Tuple packing to ensure natural ordering / grouping.
// - Embeddings are stored as packed little-endian float32 in bytes fields.
// - Timestamps are milliseconds since epoch unless specified.
// - Messages are designed to be forward-compatible; prefer adding fields over
//   modifying existing ones. Avoid changing semantics of existing fields.

// -----------------------------------------------------------------------------
// Global index metadata
// -----------------------------------------------------------------------------
// Stored once per index (key: (index, "meta") inside the index directory).
// This is written at index creation and rarely changes.
message IndexMeta {
  // Human-readable index name; also used for DirectoryLayer naming.
  string name = 1;

  // Fixed vector dimensionality (D). Must be positive and immutable across the
  // lifetime of the index. All inserted vectors MUST have this dimension.
  int32 dimension = 2;

  // Distance metric used for scoring / search pruning.
  // - METRIC_L2: Euclidean distance in R^D
  // - METRIC_COSINE: Cosine similarity (dot product on normalized vectors)
  enum Metric { METRIC_L2 = 0; METRIC_COSINE = 1; }
  Metric metric = 3;

  // Maximum number of vectors per segment before it rotates to PENDING.
  // Typical values: 50k–200k depending on memory and quality targets.
  int32 max_segment_size = 4;

  // Product Quantization (PQ) configuration:
  // - m: number of subspaces (must divide dimension)
  // - k: number of centroids per subspace (commonly 256 → 1 byte per subspace)
  int32 pq_m = 5;
  int32 pq_k = 6;

  // Graph configuration:
  // - graph_degree: target out-degree R for DiskANN-style neighbor graph
  // - oversample: multiplier of K for candidate collection before exact rerank
  int32 graph_degree = 7;
  int32 oversample = 8;
}

// -----------------------------------------------------------------------------
// Per-segment metadata
// -----------------------------------------------------------------------------
// Stored at: (segments, <segIdStr>, "meta") or equivalent flattened key.
// Maintains the lifecycle state and counters for a single segment.
message SegmentMeta {
  // Segment identifier (0-based, monotonically increasing number).
  int32 segment_id = 1;

  // Lifecycle state:
  // - ACTIVE: Accepts inserts; no graph/PQ yet; queries use brute-force.
  // - PENDING: Sealed for writes; background build (graph + PQ) in progress.
  // - SEALED: Graph and PQ complete; queries use graph + PQ for pruning.
  enum State { ACTIVE = 0; PENDING = 1; SEALED = 2; }
  State state = 2;

  // Number of non-deleted vectors currently in this segment.
  // For ACTIVE segments, this is the next vec_id to assign.
  int32 count = 3;

  // Creation time (ms since epoch). Useful for TTL, compaction heuristics, and
  // operational visibility. Not used in correctness.
  int64 created_at_ms = 4;

  // Number of vectors marked deleted in this segment. Helps maintenance tasks
  // (vacuum/compaction) decide when to reclaim space.
  int64 deleted_count = 5;
}

// -----------------------------------------------------------------------------
// Raw vector record stored under segment/vectors
// -----------------------------------------------------------------------------
// Keyed under: (segments, <segIdStr>, "vectors", <vecId>)
// Embeddings are stored in raw form for exact reranking and for ACTIVE search.
message VectorRecord {
  // Segment-local identifiers. Together (seg_id, vec_id) uniquely identify a
  // record. Global IDs, if needed externally, can be encoded via Tuple.
  int32 seg_id = 1;
  int32 vec_id = 2;

  // Packed little-endian float32 array of length = IndexMeta.dimension.
  // For cosine, callers should either pre-normalize vectors or the query path
  // should normalize on read before computing dot products.
  bytes embedding = 3;

  // Tombstone flag. True indicates the record is logically deleted. Adjacency
  // lists are not immediately updated; queries must filter deleted results.
  bool deleted = 4;

  // Optional application payload (opaque bytes). Size should be modest — for
  // large documents/metadata, store elsewhere keyed by (seg_id, vec_id).
  bytes payload = 5;
}

// -----------------------------------------------------------------------------
// Product Quantization (codebook)
// -----------------------------------------------------------------------------
// Stored once per SEALED segment:
//   (segments, <segIdStr>, "pq", "codebook")
// Each entry in `centroids` is a packed float32 array for one subspace that
// concatenates its K centroids (size = K * (D/M)).
message PQCodebook {
  // Number of subspaces (M). Must divide IndexMeta.dimension.
  int32 m = 1;
  // Centroids per subspace (K). Typically 256.
  int32 k = 2;
  // Length = m. Each element packs K centroids for one subspace.
  repeated bytes centroids = 3;
}

// -----------------------------------------------------------------------------
// Graph adjacency (DiskANN-style)
// -----------------------------------------------------------------------------
// Stored per vector for SEALED segments:
//   (segments, <segIdStr>, "graph", <vecId>)
// Contains IDs of neighbor vectors (segment-local). Degree is ~IndexMeta.graph_degree.
message Adjacency {
  // Neighbor IDs (segment-local vec_id). Order is implementation-defined; often
  // by increasing approximate proximity during construction. Consumers may
  // reorder or trim during search.
  repeated int32 neighbor_ids = 1;
}

// -----------------------------------------------------------------------------
// Task payload for background segment build
// -----------------------------------------------------------------------------
// Enqueued when a segment transitions from ACTIVE to PENDING.
message BuildTask {
  // Segment id that has been sealed (PENDING) and needs graph/PQ build.
  int32 seg_id = 1;
}

// -----------------------------------------------------------------------------
// Maintenance tasks (vacuum, compaction)
// -----------------------------------------------------------------------------
// Enqueued out-of-band to reclaim space from tombstoned vectors and (later) merge
// small segments. Vacuum is safe for v1; compaction is a no-op skeleton for now.
message MaintenanceTask {
  oneof task {
    Vacuum vacuum = 1;
    Compact compact = 2;
  }

  message Vacuum {
    int32 seg_id = 1;
    // Optional guard: only vacuum if deleted_count / (deleted_count + count) >= threshold.
    // Use 0 to always vacuum.
    double min_deleted_ratio = 2;
  }

  message Compact {
    repeated int32 seg_ids = 1;
  }
}
